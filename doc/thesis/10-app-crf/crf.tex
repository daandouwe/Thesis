% \bibliography{../src/bibliography}

The derivation of the inference algorithms in chapter \ref{04-crf} makes use of the notion of a \textit{weighted hypergraph} as a compact representation of all parses and their scores \citep{gallo1993directed,klein2004parsing}, and also makes use some of the ideas and notation of \textit{semiring parsing} \citep{goodman1999semiring,eisner2009semirings}.

\section{Hypergraph}
  We use a \textit{backward hypegraph} to compactly represent all possible trees over a sentence under a grammar, an idea introduced in \citet{klein2004parsing}. We call such hypergraph a parse forest.

  \begin{definition}{}
    A \textit{directed hypergraph} is a pair $G = (V, E)$, consisting of a set of nodes $V$, and a set of directed hyperedges $E \subseteq 2^V \times 2^V$ that connect a set of nodes at the \textit{tail} of the arrow to a set of node at the \textit{head} of the arrow.
  \end{definition}

  \begin{definition}{}
    A \textit{backward-hypergraph} is a directed hypergraph where the hyperedges $E \subseteq 2^V \times V$ connect to a single node. For a node $v \in V$ the set $I(v) \subseteq E$ denotes the set of edges incoming at $v$ and the set $O(v) \subseteq E$ denotes the set of edges outgoing from $v$, $\ie$ the edges for which $v$ is in the tail. For an edge $e$ we write $T(e) \subseteq V$ for the set of nodes in the tail of $e$, and define $H(e) \in V$ as the node at the head of the edge.
  \end{definition}

  \begin{definition}{}
     A \textit{weighted hypergraph} is any hypergraph $G$ equided with a weight function $\omega : E \to K$ that to each edge assigns a weight from a weight-set $K$. Typically $K$ the set of real numbers, or the set of integers.
  \end{definition}

  \begin{definition}{}
    A \textit{hyperpath} in a backward-hypergraph is a set of edges that connects a single node $v \in V$ at the sink to a set of nodes $W \subseteq V$ upstream. Formally defining a hyperpath is a little cumbersome, but informally, a hyperpath is a set of edges obtained by the following recursive procedure: starting at $v$, follow a single incoming hyperarc $e$ backwards, save the edge and repeat this for all nodes in $T(e)$; stop when all nodes in $W$ have been encountered. In the context of parsing we also call a hyperpath from the root node to the set of words $\{ x_1, \dots, \x_n \}$ a \textit{derivation}: this hyperpath represents a single tree for the sentence.
  \end{definition}

  % \begin{example}{(CRF parser)
  %   \label{ex:crf}
  %   The hypergraph specified by the CRF parser in chapter \ref{04-crf} has the following structure. Let the set $V$ consists of the invidual words of a sentence $x$, together with the all posible labeled spans over that sentence:
  %   \begin{align*}
  %     V = \Big\{ \x_i \; \Big\vert \; 1 \leq i \leq n \Big\} \cup \Big\{ (A, i, j) \; \Big\vert \; A \in \Lambda, 0 \leq i < j \leq n \Big\} \cup \Big\{ (S^{\dagger}, 0, n) \Big\}.
  %   \end{align*}
  %   The edge set $E$ will specify all the ways that adjacent constituents can be combined to form a larger constituent, under a particular grammar. Because we (implicitly) use a normal form grammar that contains \textit{all} possible productions, the set of hyperedges is particularly regular: the set $E$ contains all edges that connect nodes $(B, i, k)$ and $(C, k, j)$ at the tail with $(A, i, j)$ at the head for all $0 \leq i < k < j \leq n$, all edges that connect $\x_i$ to $(A, i, i+1)$, and all nodes can function as top nodes:
  %   \begin{align*}
  %     E
  %       &= \Bigg\{ \Big\langle \Big\{ (B, i, k), (C, k, j) \Big\},  (A, i, j) \Big\rangle \; \Bigg\vert \; A, B, C \in \Lambda, \; 0 \leq i < k < j \leq n \Bigg\}  \\
  %       &\quad\cup \Bigg\{ \Big\langle \{ \x_i \}, (A, i-1, i) \Big\rangle \; \Bigg\vert \; A \in \Lambda, \; 1 \leq i \leq n \Bigg\}  \\
  %       &\quad\cup \Bigg\{ \Big\langle \{ (A, 0, n) \}, (S^{\dagger}, 0, n) \Big\rangle \; \Bigg\vert \; A \in \Lambda \Bigg\}
  %   \end{align*}
  %   The three kind of edges in $E$ are illusrated in figure \ref{fig:edges} and figure \ref{fig:hypergraph} shows a fragment of this hypergraph for an example sentence. Shown are the two hyperpaths corresponding to the two (overlapping) derivations
  %   \begin{align}
  %     % &\text{(S (NP \textit{The very hungry cat}) (VP \textit{meows}) .)}  \\
  %     &\text{(S (NP \textit{The} (ADJP \textit{very hungry}) \textit{cat}) (VP \textit{meows}) .)}  \\
  %     &\text{(S (NP \textit{The} (NP (ADJP \textit{very hungry}) \textit{cat})) (VP \textit{meows}) .)}
  %   \end{align}
  %   after collapsing the empty nodes $\varnothing$.
  % \end{example}
  %
  % \begin{figure}[h]
  %   \center
  %   \begin{tikzpicture}[scale=.6]
  %     \input{../figures/edges/edges.tex}
  %   \end{tikzpicture}
  %   \caption{The three types of edges making up the hypergraph of example \ref{ex:crf}.}
  %   \label{fig:edges}
  % \end{figure}
  %
  % In the above example, the edges that direct to the special node $(S^{\dagger}, 0, n)$ make the hypergraph \textit{rooted}: each \textit{hyperpath} with the set of all words at the source ends at this one node.

  \begin{example}{(Parse forest)}
    Figure \ref{fig:hypergraph} shows a fragment of a hypergraph that represents the parse forest over an example sentence. Shown are the two hyperpaths corresponding to the two partially overlapping derivations
    \begin{align}
      % &\text{(S (NP \textit{The very hungry cat}) (VP \textit{meows}) .)}  \\
      &\text{(S (NP \textit{The} (ADJP \textit{very hungry}) \textit{cat}) (VP \textit{meows}) .)}  \\
      &\text{(S (NP \textit{The} (NP (ADJP \textit{very hungry}) \textit{cat})) (VP \textit{meows}) .)}
    \end{align}
    after collapsing the empty nodes $\varnothing$. The edges that direct to the special node $(S^{\dagger}, 0, n)$ make the hypergraph \textit{rooted}: each \textit{hyperpath} with the set of all words at the source ends at this one node.
    \begin{figure}[h]
      \center
      \begin{tikzpicture}[scale=.6]
        \input{../figures/hypergraph/hypergraph.tex}
      \end{tikzpicture}
      \caption{A fraction of a parse hypergraph showing two possible parses.}
      \label{fig:hypergraph}
    \end{figure}
  \end{example}

\section{Semiring}
  We use \textit{semirings} to compute various quantities of interest over a weighted hypergraph.

  \begin{definition}{}
    A \textit{semiring} is an algebraic structure
    \begin{align*}
      \mathcal{K} = ( \mathbb{K}, \oplus, \otimes, \bar{0}, \bar{1} ),
    \end{align*}
    over a field $\mathbb{K}$, with additive and multiplicative operations $\oplus$ and $\otimes$, and additive and multiplicative identities $\bar{0}$ and $\bar{1}$. A semiring is equivalent to a ring\footnote{Perhaps the most common algebraic structure around: the real numbers with regular addition and multiplication form a ring.}, without the requirement of an additive inverse for each element.
  \end{definition}

  Some of the semirings relevant to our discussion are the following:
  \begin{example}{}
    The \textit{real semiring}
    \begin{align*}
      ( \reals_{\geq 0}, +, \times, 0, 1 ),
    \end{align*}
    defined over the nonnegative reals, with regular addition and multiplication is a semiring. Note that the additive inverse is missing for all elements greater than zero ($\ie$ missing the negative reals).
  \end{example}

  \begin{example}{}
    The \textit{boolean semiring}
    \begin{align*}
      ( \{ \top, \bot \}, \vee, \wedge, \top, \bot  ),
    \end{align*}
    is defined over truth values $\top$ (True, or 1), and $\bot$ (False, or 0). The binary operations are the logical `and' and `or' operations.
  \end{example}

  \begin{example}{}
    The \textit{log-real semiring},
    \begin{align*}
      ( \reals \cup \{ - \infty \}, \oplus, +, -\infty, 0 ),
    \end{align*}
    defined over the reals extended including $\infty$, with addition defined as the logarithmic sum\footnote{Also known as \textit{log-sum-exp}, or \textit{log-add-exp}.}
    \begin{align*}
      a \oplus b = \log( e^{a} + e^{b} ),
    \end{align*}
   and multiplication is defined as regular addition.
  \end{example}

  \begin{example}{}
    The \textit{max-tropical semiring}, or \textit{Viterbi} semiring\footnote{This naming will become clear.}
    \begin{align*}
      ( \reals_{\geq 0} \cup \{ -\infty \}, \max, +, -\infty, 0 ),
    \end{align*}
    is the log-real semiring that uses the $\max$ operator for addition.
  \end{example}

\section{Semiring parsing}
  A semiring $\mathcal{K}$ can be connected to a weighted hypergraph by defining the function $\omega$ over its field $\mathbb{K}$, and by accumulating the weights with its binary operations. When the hypergraph represents a parse forest, we are in the realm of \textit{semiring parsing} \citep{goodman1999semiring}.

  The key result derived by \citet{goodman1999semiring} is that many quantities of interest can be computed by a single recursion but over different semirings. First, we establish the relation between the weight function and the structures encoded in the hypergraph by defining the weight of a derivation and the weight of an entire hypergraph.

  \begin{definition}{(Hypergraph weights)} Let $G_{\omega} = (V, E, \omega)$ be a weighted hypergraph, with $\omega$ defined over a semiring $\mathcal{K}$. We define the weight of the derrivation $D \subseteq E$ as the product of the weights of the edges:
  \begin{align}
    \label{eq:derivation-weight}
    \bigotimes_{e \in D} \omega(e).
  \end{align}
  Let $\mathcal{D} \subseteq 2^E$ be the set of all derivations in the hypergraph $G$. Then the total weight of the hypergraph under $\omega$ is defined as the sum of the weights of all the derrivations in it:
  \begin{align}
    \label{eq:hypergraph-weight}
    \bigoplus_{D \in \mathcal{D}} \bigotimes_{e \in D} \omega(e).
  \end{align}
  \end{definition}

  \begin{example}{(CRF parser)}
    The CRF parser assigns a score $\Psi(\x, \y) \geq 0$ by factorizing over parts of $\y = \{ \y_a \}_{a=1}^{A}$ as a product of potentials $\psi(\x, \y_a) \geq 0$ of the parts. The parts $\y_a$ are the edges in the hyperpath that create the derivation $\y$. In our CRF, thus, the weight function $\omega$ is given by the function $\psi$; the function $\Psi$ is equivalent to equation \ref{eq:derivation-weight}; and the sum over $\yieldx$ is equivalent to equation \ref{eq:hypergraph-weight}.
  \end{example}

  \subsection{Inside and outside recursions}
  We follow the exposition of \citet{eisner2009semirings}, but the results where first derived in \citet{goodman1999semiring}.

  \begin{definition}{} The \textit{inside value} $\alpha(v)$ at a node $v \in V$ accumulates the weight of all the paths that converge at that node. The accumulation is relative to a semiring, and is defined as
  \begin{align*}
    \alpha(v) =
      \begin{cases}
        \bar{1}  &  \mbox{if } I(v) = \varnothing,  \\
        \displaystyle\bigoplus_{e \in I(v)} \omega(e) \otimes \displaystyle\bigotimes_{u \in T(e)} \alpha(u)  & \mbox{otherwise.}
      \end{cases}
  \end{align*}
  The value $\alpha(v)$ at the root node $v$ is the sum of the weight of all the derivations in the hypergraph. The recursion can solved by visiting the nodes in $V$ in topological order.
  \end{definition}

  \begin{definition}{} The \textit{outside value} $\beta(v)$ at a node $v \in V$ accumulates over the weights of all the paths that head out from $v$. The accumulation is relative to a semiring, and is defined as:
  \begin{align*}
    \beta(v) =
      \begin{cases}
        \bar{1}  & \mbox{if } O(v) = \varnothing, \\
        \displaystyle\bigoplus_{e \in O(v)} \omega(w) \otimes \beta(H(e)) \otimes \displaystyle\bigotimes_{ \substack{ w \in T(e) \\ w \neq u } } \alpha(w)  & \mbox{otherwise.}
      \end{cases}
  \end{align*}
  The recursion can solved by visiting the nodes in $V$ in reverse topological order.
  \end{definition}

\subsection{Instantiated recursions}

By instanstiating the inside and outside recursions with different semirings we solve a whole range of problems.

\begin{example}{(Inside and outside values)}
  When we intantiate the inside recursion and the outside recursion with the \textit{real semiring}, the algorithms recude to the classical inside-outside algorithm \citep{baker1979trainable}. The values $\alpha(v)$ and $\beta(v)$ are the inside and outside values. In particular, the value of $\alpha$ at the root is the normalizer:
  \begin{align*}
    \alpha(\text{S}^{\dagger}, 0, n) = Z(\x).
  \end{align*}
  In our CRF parser, the function $\omega$ is given by the nonnegative function $\Psi$.
\end{example}

\begin{example}{(Logartihmic domain)}
  When we are concerned with numerical stability, or we only need the logarithm of the quantities of interest, we can use the \textit{log-real semiring}. The values $\alpha(v)$ and $\beta(v)$ now give the log-inside and log-outside values respectively. In particular, the value $\alpha$ at the root now gives the lognormalizer:
  \begin{align*}
    \alpha(\text{S}^{\dagger}, 0, n) = \log Z(\x).
  \end{align*}
  The semiring addition $a \oplus b = \log(e^{a} + e^{b})$ is made numerically stable by writing
  \begin{align*}
    \log(e^{a} + e^{b}) = a + \log(1 + e^{b-a}) = b + \log(1 + e^{a-b})
  \end{align*}
  and choosing the expression with the smaller exponent. In the CRF, the function $\omega$ is given by the composed function $\log \circ \Psi$.
\end{example}

\begin{example}{(Viterbi weight)}
  \label{ex:vit-weight}
  When we intantiate the inside recursion with the \textit{max-tropical semiring} we get the recursion that computes at each node the subtree of maximum weight. The value $\alpha$ at the root is the weight of the derrivation with the maximum weight
  \begin{align*}
    \alpha(\text{S}^{\dagger}, 0, n) = \log \Psi(\x, \hat{\y}),
  \end{align*}
  where $\hat{\y}$ is the Viterbi tree. Normalizing the score with the lognormalizer gives the log-probability
  \begin{align*}
    \log p(\hat{\y} \mid \x) = \alpha(\text{S}^{\dagger}, 0, n) - \log Z(\x).
  \end{align*}
  Hence the alternative name \textit{Viterbi semiring}.
\end{example}

\begin{example}{(Viterbi derivation)}
  \label{ex:vit-derivation}
  The Viterbi semiring derives the \textit{weight} of the best tree. Replacing the max in the Viterbi semiring with an argmax derives the best tree itself:
  \begin{align*}
    \alpha(\text{S}^{\dagger}, 0, n) = \hat{\y}, \qquad \hat{\y} \defeq \argmax_{\y \in \yieldx} p(\y \mid \x).
  \end{align*}
  Roughly spearking, because although this idea can be made precise by a constructing the \textit{Viterbi-derivation semiring} \citep{goodman1999semiring} over the set of possible derrivations, with corresponding binary operations and set-typed identity elements $\bar{0}$ and $\bar{1}$, it is a litle more complicated than that\footnote{And most of all, a bit cumbersome.}.
\end{example}

\begin{example}{(Recognition)}
  When we intantiate the inside recursion with the \textit{boolean semiring} we get the recursion that recognizes wheter a hyperpath exists from the words spanned by the node:
  \begin{align*}
    \alpha(\text{S}^{\dagger}, 0, n) &= \begin{cases}
      \top & \mbox{if } \x \in L(G),  \\
      \bot & \mbox{otherwise.}
  \end{cases}
  \end{align*}
  The value at the root tells wether the sentence has at least one parse. Due to the trivial grammar used this will always be $\top$ in our CRF.
\end{example}
